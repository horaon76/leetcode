<html>
<head>
<title>Fibonacci.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #000000;}
.s1 { color: #000000;}
.s2 { color: #000080; font-weight: bold;}
.s3 { color: #660e7a; font-weight: bold; font-style: italic;}
.s4 { color: #008000; font-weight: bold;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Fibonacci.md</font>
</center></td></tr></table>
<pre>Here's a detailed example of calculating the Fibonacci series in Java using Dynamic Programming (DP). We'll include both a **Top-Down (Memoization)** and a **Bottom-Up (Tabulation)** approach, along with a few examples.

<span class="s2">---</span>

<span class="s2">### </span>Top-Down Approach (Memoization)
This approach uses recursion with a cache (array) to store previously computed values.

<span class="s2">```</span><span class="s3">java</span>
<span class="s4">import java.util.Arrays;</span>

<span class="s4">public class FibonacciDP {</span>

    <span class="s4">// Top-Down Approach (Memoization)</span>
    <span class="s4">public static int fibonacciTopDown(int n, int[] memo) {</span>
        <span class="s4">if (n &lt;= 1) return n;</span>
        <span class="s4">if (memo[n] != -1) return memo[n]; // Return cached result if available</span>

        <span class="s4">memo[n] = fibonacciTopDown(n - 1, memo) + fibonacciTopDown(n - 2, memo); // Recursive call</span>
        <span class="s4">return memo[n];</span>
    <span class="s4">}</span>

    <span class="s4">public static void main(String[] args) {</span>
        <span class="s4">int n = 10; // Example: Find the 10th Fibonacci number</span>
        <span class="s4">int[] memo = new int[n + 1];</span>
        <span class="s4">Arrays.fill(memo, -1); // Initialize cache with -1</span>
        
        <span class="s4">System.out.println(&quot;Fibonacci (&quot; + n + &quot;) using Memoization: &quot; + fibonacciTopDown(n, memo));</span>
    <span class="s4">}</span>
<span class="s4">}</span>
<span class="s2">```</span>

<span class="s2">---</span>

<span class="s2">### </span>Bottom-Up Approach (Tabulation)
This approach uses an iterative method to fill up a table (array) from the base case.

<span class="s2">```</span><span class="s3">java</span>
<span class="s4">public class FibonacciDP {</span>

    <span class="s4">// Bottom-Up Approach (Tabulation)</span>
    <span class="s4">public static int fibonacciBottomUp(int n) {</span>
        <span class="s4">if (n &lt;= 1) return n;</span>

        <span class="s4">int[] dp = new int[n + 1];</span>
        <span class="s4">dp[0] = 0;</span>
        <span class="s4">dp[1] = 1;</span>

        <span class="s4">for (int i = 2; i &lt;= n; i++) {</span>
            <span class="s4">dp[i] = dp[i - 1] + dp[i - 2];</span>
        <span class="s4">}</span>

        <span class="s4">return dp[n];</span>
    <span class="s4">}</span>

    <span class="s4">public static void main(String[] args) {</span>
        <span class="s4">int n = 10; // Example: Find the 10th Fibonacci number</span>

        <span class="s4">System.out.println(&quot;Fibonacci (&quot; + n + &quot;) using Tabulation: &quot; + fibonacciBottomUp(n));</span>
    <span class="s4">}</span>
<span class="s4">}</span>
<span class="s2">```</span>

<span class="s2">---</span>

<span class="s2">### </span>Optimized Space Approach
To optimize space, we can store only the last two Fibonacci numbers instead of maintaining a full array.

<span class="s2">```</span><span class="s3">java</span>
<span class="s4">public class FibonacciDP {</span>

    <span class="s4">// Optimized Space Approach</span>
    <span class="s4">public static int fibonacciOptimized(int n) {</span>
        <span class="s4">if (n &lt;= 1) return n;</span>

        <span class="s4">int prev2 = 0, prev1 = 1, current = 0;</span>

        <span class="s4">for (int i = 2; i &lt;= n; i++) {</span>
            <span class="s4">current = prev1 + prev2;</span>
            <span class="s4">prev2 = prev1;</span>
            <span class="s4">prev1 = current;</span>
        <span class="s4">}</span>

        <span class="s4">return current;</span>
    <span class="s4">}</span>

    <span class="s4">public static void main(String[] args) {</span>
        <span class="s4">int n = 10; // Example: Find the 10th Fibonacci number</span>

        <span class="s4">System.out.println(&quot;Fibonacci (&quot; + n + &quot;) using Optimized Space: &quot; + fibonacciOptimized(n));</span>
    <span class="s4">}</span>
<span class="s4">}</span>
<span class="s2">```</span>

<span class="s2">---</span>

<span class="s2">### </span>Example Output
For \( n = 10 \):
<span class="s2">- </span>Fibonacci number using Memoization: `55`
<span class="s2">- </span>Fibonacci number using Tabulation: `55`
<span class="s2">- </span>Fibonacci number using Optimized Space: `55`

<span class="s2">### </span>Explanation of DP:
<span class="s2">- </span>**Subproblem**: Fibonacci at position `n` depends on the Fibonacci at positions `n-1` and `n-2`.
<span class="s2">- </span>**State**: `dp[i]` stores the Fibonacci number at position `i`.
<span class="s2">- </span>**Transition**: `dp[i] = dp[i-1] + dp[i-2]`.
<span class="s2">- </span>**Base Case**: `dp[0] = 0` and `dp[1] = 1`.

<span class="s2">### </span>Complexity:
<span class="s2">- </span>**Time Complexity**: \( O(n) \) for all approaches.
<span class="s2">- </span>**Space Complexity**:
    <span class="s2">- </span>Memoization: \( O(n) \) for the cache.
    <span class="s2">- </span>Tabulation: \( O(n) \) for the array.
    <span class="s2">- </span>Optimized Space: \( O(1) \).
<span class="s2">- </span>The DP array in Fibonacci calculations is often of size \( n+1 \) because we want to store the Fibonacci numbers for indices from \( 0 \) to \( n \), inclusive. Here's a detailed explanation:

<span class="s2">---</span>

<span class="s2">### </span>Key Points:

<span class="s2">1. </span>**Indexing Starts from 0**:
    <span class="s2">- </span>Fibonacci numbers are indexed starting from \( 0 \), i.e., \( F(0) = 0 \) and \( F(1) = 1 \).
    <span class="s2">- </span>To compute \( F(n) \), we need values for \( F(0), F(1), \dots, F(n) \).

<span class="s2">2. </span>**Storage for All Values**:
    <span class="s2">- </span>If the DP array is of size \( n \), the highest index we can access is \( n-1 \).
    <span class="s2">- </span>For \( F(n) \), we need the \( n \)-th index as well, so the array needs to be of size \( n+1 \).

<span class="s2">3. </span>**Example**:
    <span class="s2">- </span>For \( n = 5 \):
        <span class="s2">- </span>Fibonacci sequence: \( 0, 1, 1, 2, 3, 5 \).
        <span class="s2">- </span>DP array indices: \( 0, 1, 2, 3, 4, 5 \).
        <span class="s2">- </span>The DP array must be of size \( 6 \) (i.e., \( n+1 \)) to accommodate all these values.

<span class="s2">---</span>

<span class="s2">### </span>Code Example:

<span class="s2">#### </span>Incorrect Array Size
If we use an array of size \( n \), it will result in an error:

<span class="s2">```</span><span class="s3">java</span>
<span class="s4">int n = 5;</span>
<span class="s4">int[] dp = new int[n]; // Size is 5</span>

<span class="s4">dp[0] = 0;</span>
<span class="s4">dp[1] = 1;</span>

<span class="s4">for (int i = 2; i &lt;= n; i++) { // Accessing dp[5] will throw ArrayIndexOutOfBoundsException</span>
    <span class="s4">dp[i] = dp[i-1] + dp[i-2];</span>
<span class="s4">}</span>
<span class="s2">```</span>

<span class="s2">#### </span>Correct Array Size
To avoid the error, the array must be of size \( n+1 \):

<span class="s2">```</span><span class="s3">java</span>
<span class="s4">int n = 5;</span>
<span class="s4">int[] dp = new int[n + 1]; // Size is 6</span>

<span class="s4">dp[0] = 0;</span>
<span class="s4">dp[1] = 1;</span>

<span class="s4">for (int i = 2; i &lt;= n; i++) { // Accessing dp[5] is valid</span>
    <span class="s4">dp[i] = dp[i-1] + dp[i-2];</span>
<span class="s4">}</span>
<span class="s4">System.out.println(&quot;Fibonacci (&quot; + n + &quot;) = &quot; + dp[n]); // Output: 5</span>
<span class="s2">```</span>

<span class="s2">---</span>

<span class="s2">### </span>Why is This Important?

<span class="s2">- </span>**Prevention of Indexing Errors**: Using \( n+1 \) ensures we don't run into `ArrayIndexOutOfBoundsException`.
<span class="s2">- </span>**Inclusive Computation**: It allows us to compute and store Fibonacci numbers up to \( F(n) \), including the \( n \)-th number.
<span class="s2">- </span>**Consistency**: This approach makes it easier to understand and implement DP solutions without special edge-case handling.

By allocating \( n+1 \) space, the DP table cleanly handles indices \( 0 \) through \( n \).</pre>
</body>
</html>